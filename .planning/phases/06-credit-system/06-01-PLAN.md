---
phase: 06-credit-system
plan: 01
title: Lemon Squeezy SDK Setup + Webhook Handler
depends_on: [05-05]
parallel: false
ai_context: |
  Phase 6 첫 번째 플랜: Lemon Squeezy SDK 설정 및 웹훅 핸들러 구현.
  Phase 4에서 purchases 테이블과 add_credit 함수가 이미 구현됨.
  lemon_squeezy_order_id UNIQUE 제약으로 idempotency 보장됨.
---

# 06-01: Lemon Squeezy SDK + Webhook Handler

## Overview

Lemon Squeezy SDK 설치 및 초기화, 웹훅 핸들러 구현. 이 플랜에서는 결제 이벤트를 수신하고 크레딧을 충전하는 백엔드 인프라를 구축합니다.

## Prerequisites

- Phase 5 완료 (PRD 생성 기능)
- Phase 4의 `add_credit` 함수 및 `purchases` 테이블

## Tasks

### Task 1: Lemon Squeezy SDK 설치 및 환경 변수 설정

**Files to create/modify:**
- `.env.example` - 환경 변수 추가
- `src/shared/lib/lemon-squeezy/client.ts` - SDK 초기화

**Implementation:**

```bash
npm install @lemonsqueezy/lemonsqueezy.js
```

```typescript
// src/shared/lib/lemon-squeezy/client.ts
import { lemonSqueezySetup } from '@lemonsqueezy/lemonsqueezy.js';

export function initLemonSqueezy() {
  const apiKey = process.env.LEMONSQUEEZY_API_KEY;
  if (!apiKey) {
    throw new Error('LEMONSQUEEZY_API_KEY is not configured');
  }
  lemonSqueezySetup({ apiKey });
}
```

**Environment variables to add:**
```env
# Lemon Squeezy
LEMONSQUEEZY_API_KEY=
LEMONSQUEEZY_STORE_ID=
LEMONSQUEEZY_WEBHOOK_SECRET=

# Variant IDs (Product variants in Lemon Squeezy)
NEXT_PUBLIC_LS_VARIANT_STARTER=
NEXT_PUBLIC_LS_VARIANT_BASIC=
NEXT_PUBLIC_LS_VARIANT_PRO=
NEXT_PUBLIC_LS_VARIANT_BUSINESS=
```

**Verification:**
- [ ] 패키지 설치 확인
- [ ] 빌드 성공

---

### Task 2: 서명 검증 유틸리티 생성

**File to create:**
- `src/shared/lib/lemon-squeezy/verify-signature.ts`

**Implementation:**

```typescript
// src/shared/lib/lemon-squeezy/verify-signature.ts
import crypto from 'node:crypto';

/**
 * Verify Lemon Squeezy webhook signature using timing-safe comparison.
 *
 * @param rawBody - Raw request body string
 * @param signature - X-Signature header value
 * @param secret - Webhook secret from environment
 * @returns true if signature is valid
 */
export function verifyWebhookSignature(
  rawBody: string,
  signature: string,
  secret: string
): boolean {
  if (!signature || !rawBody || !secret) return false;

  const hmac = crypto
    .createHmac('sha256', secret)
    .update(rawBody)
    .digest('hex');

  try {
    return crypto.timingSafeEqual(
      Buffer.from(hmac, 'utf8'),
      Buffer.from(signature, 'utf8')
    );
  } catch {
    // Buffer length mismatch
    return false;
  }
}
```

**Verification:**
- [ ] 타입 검사 통과
- [ ] crypto import 문제 없음 (Node.js 환경)

---

### Task 3: Webhook 타입 정의

**File to create:**
- `src/features/purchase/model/webhook-types.ts`

**Implementation:**

```typescript
// src/features/purchase/model/webhook-types.ts

export interface LemonSqueezyWebhookMeta {
  event_name:
    | 'order_created'
    | 'order_refunded'
    | 'subscription_created'
    | 'subscription_updated'
    | 'subscription_cancelled';
  custom_data?: {
    user_id?: string;
  };
  webhook_id: string;
}

export interface LemonSqueezyOrderAttributes {
  store_id: number;
  customer_id: number;
  identifier: string;
  order_number: number;
  currency: string;
  currency_rate: string;
  subtotal: number;
  discount_total: number;
  tax: number;
  total: number;
  subtotal_usd: number;
  discount_total_usd: number;
  tax_usd: number;
  total_usd: number;
  tax_name: string | null;
  status: 'pending' | 'failed' | 'paid' | 'refunded';
  status_formatted: string;
  refunded: boolean;
  refunded_at: string | null;
  first_order_item: {
    id: number;
    order_id: number;
    product_id: number;
    variant_id: number;
    product_name: string;
    variant_name: string;
    price: number;
    quantity: number;
    created_at: string;
    updated_at: string;
  };
  test_mode: boolean;
  created_at: string;
  updated_at: string;
}

export interface LemonSqueezyWebhookEvent {
  meta: LemonSqueezyWebhookMeta;
  data: {
    type: 'orders';
    id: string;
    attributes: LemonSqueezyOrderAttributes;
  };
}
```

**Verification:**
- [ ] 타입 빌드 성공

---

### Task 4: 크레딧 패키지 정의

**Files to create:**
- `src/features/purchase/model/credit-packages.ts`
- `src/features/purchase/model/variant-mapping.ts`

**Implementation:**

```typescript
// src/features/purchase/model/credit-packages.ts
import type { CreditPackage } from '@/src/entities';

export interface CreditPackageConfig {
  name: string;
  description: string;
  credits: number;
  priceUsd: number;
  variantId: string;
  popular?: boolean;
}

export const CREDIT_PACKAGES: Record<CreditPackage, CreditPackageConfig> = {
  starter: {
    name: 'Starter',
    description: '가볍게 시작하기',
    credits: 10,
    priceUsd: 9,
    variantId: process.env.NEXT_PUBLIC_LS_VARIANT_STARTER || '',
  },
  basic: {
    name: 'Basic',
    description: '인기 패키지',
    credits: 30,
    priceUsd: 19,
    variantId: process.env.NEXT_PUBLIC_LS_VARIANT_BASIC || '',
    popular: true,
  },
  pro: {
    name: 'Pro',
    description: '전문가용',
    credits: 100,
    priceUsd: 49,
    variantId: process.env.NEXT_PUBLIC_LS_VARIANT_PRO || '',
  },
  business: {
    name: 'Business',
    description: '팀/기업용',
    credits: 300,
    priceUsd: 99,
    variantId: process.env.NEXT_PUBLIC_LS_VARIANT_BUSINESS || '',
  },
};
```

```typescript
// src/features/purchase/model/variant-mapping.ts
import { CREDIT_PACKAGES, type CreditPackageConfig } from './credit-packages';
import type { CreditPackage } from '@/src/entities';

/**
 * Find credit package by Lemon Squeezy variant ID.
 * Used in webhook handler to determine credits to add.
 */
export function getPackageByVariantId(variantId: number | string): {
  key: CreditPackage;
  config: CreditPackageConfig;
} | null {
  const variantIdStr = String(variantId);

  for (const [key, config] of Object.entries(CREDIT_PACKAGES)) {
    if (config.variantId === variantIdStr) {
      return { key: key as CreditPackage, config };
    }
  }
  return null;
}
```

**Verification:**
- [ ] CreditPackage 타입이 entities에 정의되어 있는지 확인
- [ ] 타입 검사 통과

---

### Task 5: Webhook 핸들러 구현

**File to create:**
- `src/app/api/webhook/lemon-squeezy/route.ts`

**Implementation:**

```typescript
// src/app/api/webhook/lemon-squeezy/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { verifyWebhookSignature } from '@/src/shared/lib/lemon-squeezy/verify-signature';
import { getPackageByVariantId } from '@/src/features/purchase/model/variant-mapping';
import type { LemonSqueezyWebhookEvent } from '@/src/features/purchase/model/webhook-types';
import type { Database } from '@/src/shared/types/database';

export const runtime = 'nodejs'; // crypto module requires Node.js runtime

export async function POST(request: NextRequest) {
  const secret = process.env.LEMONSQUEEZY_WEBHOOK_SECRET;

  if (!secret) {
    console.error('LEMONSQUEEZY_WEBHOOK_SECRET not configured');
    return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
  }

  // 1. Read raw body (must be done before any parsing)
  const rawBody = await request.text();

  // 2. Verify signature
  const signature = request.headers.get('X-Signature') ?? '';

  if (!verifyWebhookSignature(rawBody, signature, secret)) {
    console.error('Invalid webhook signature');
    return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
  }

  // 3. Parse event
  let event: LemonSqueezyWebhookEvent;
  try {
    event = JSON.parse(rawBody);
  } catch {
    return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 });
  }

  const eventName = event.meta.event_name;
  console.log(`Received webhook: ${eventName}`);

  // 4. Only process order_created events
  if (eventName !== 'order_created') {
    return NextResponse.json({ message: 'Event ignored' }, { status: 200 });
  }

  const orderId = event.data.id;
  const userId = event.meta.custom_data?.user_id;
  const status = event.data.attributes.status;
  const testMode = event.data.attributes.test_mode;

  // 5. Validate required data
  if (!userId) {
    console.error('Missing user_id in custom_data');
    return NextResponse.json({ error: 'Missing user_id' }, { status: 400 });
  }

  if (status !== 'paid') {
    console.log(`Order ${orderId} status is ${status}, skipping`);
    return NextResponse.json({ message: 'Order not paid' }, { status: 200 });
  }

  // 6. Skip test orders in production
  if (testMode && process.env.NODE_ENV === 'production') {
    console.log(`Test order ${orderId} ignored in production`);
    return NextResponse.json({ message: 'Test order ignored' }, { status: 200 });
  }

  // 7. Get package info from variant ID
  const variantId = event.data.attributes.first_order_item.variant_id;
  const packageInfo = getPackageByVariantId(variantId);

  if (!packageInfo) {
    console.error(`Unknown variant ID: ${variantId}`);
    return NextResponse.json({ error: 'Unknown variant' }, { status: 400 });
  }

  // 8. Create Supabase client with service role (bypass RLS)
  const supabase = createClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  // 9. Insert purchase record (idempotency via UNIQUE constraint)
  const { error: insertError } = await supabase
    .from('purchases')
    .insert({
      user_id: userId,
      package: packageInfo.key,
      credits_amount: packageInfo.config.credits,
      amount_cents: event.data.attributes.total,
      currency: event.data.attributes.currency,
      lemon_squeezy_order_id: orderId,
      status: 'completed',
      completed_at: new Date().toISOString(),
    });

  if (insertError) {
    // 23505 = unique_violation (already processed)
    if (insertError.code === '23505') {
      console.log(`Order ${orderId} already processed`);
      return NextResponse.json({ message: 'Already processed' }, { status: 200 });
    }

    console.error('Failed to insert purchase:', insertError);
    return NextResponse.json({ error: 'Database error' }, { status: 500 });
  }

  // 10. Add credits using existing RPC function
  const { error: creditError } = await supabase.rpc('add_credit', {
    p_user_id: userId,
    p_amount: packageInfo.config.credits,
    p_usage_type: 'credit_purchase',
    p_description: `Credit purchase: ${packageInfo.config.name} package (order ${orderId})`,
  });

  if (creditError) {
    console.error('Failed to add credits:', creditError);
    // Purchase recorded but credits failed - needs manual intervention
    return NextResponse.json({ error: 'Credit addition failed' }, { status: 500 });
  }

  console.log(`Successfully processed order ${orderId}: +${packageInfo.config.credits} credits for user ${userId}`);

  return NextResponse.json({ success: true }, { status: 200 });
}
```

**Verification:**
- [ ] 빌드 성공
- [ ] runtime = 'nodejs' 설정 확인 (crypto 모듈 필요)

---

### Task 6: Feature 모듈 barrel export

**Files to create:**
- `src/features/purchase/model/index.ts`
- `src/features/purchase/index.ts`

**Implementation:**

```typescript
// src/features/purchase/model/index.ts
export { CREDIT_PACKAGES, type CreditPackageConfig } from './credit-packages';
export { getPackageByVariantId } from './variant-mapping';
export type {
  LemonSqueezyWebhookEvent,
  LemonSqueezyWebhookMeta,
  LemonSqueezyOrderAttributes,
} from './webhook-types';
```

```typescript
// src/features/purchase/index.ts
export { CREDIT_PACKAGES, type CreditPackageConfig } from './model';
export { getPackageByVariantId } from './model';
// UI exports will be added in 06-02
```

**Verification:**
- [ ] Import 경로 테스트
- [ ] 빌드 성공

---

## Checkpoint: Build Verification

```bash
npm run build
```

**Expected outcome:**
- 빌드 성공
- 타입 에러 없음

**Human verification needed:**
- Lemon Squeezy 대시보드에서 웹훅 URL 설정 필요 (배포 후)
- 환경 변수 설정 필요 (API 키, Store ID, Variant IDs)

---

## Files Summary

### Created
- `src/shared/lib/lemon-squeezy/client.ts`
- `src/shared/lib/lemon-squeezy/verify-signature.ts`
- `src/features/purchase/model/webhook-types.ts`
- `src/features/purchase/model/credit-packages.ts`
- `src/features/purchase/model/variant-mapping.ts`
- `src/features/purchase/model/index.ts`
- `src/features/purchase/index.ts`
- `src/app/api/webhook/lemon-squeezy/route.ts`

### Modified
- `.env.example`

---

## Notes

- Webhook 테스트는 Lemon Squeezy 대시보드 또는 ngrok으로 로컬 테스트 가능
- `runtime = 'nodejs'`로 설정해야 crypto 모듈 사용 가능 (Edge Runtime 불가)
- Phase 4에서 이미 `add_credit` 함수가 `usage_logs`에 로그 기록함
